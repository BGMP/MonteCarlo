////////////////////////////////////////////////////////////////////////////////
//
// MonteCarlo (Generic)
//
// Desc: math_MonteCarloParallel.cpp
// Parallel implementation of the Monte Carlo method.
//
// 14/10/2024 (BGM)
// File inception.
//
////////////////////////////////////////////////////////////////////////////////

#include "../include/math_MonteCarloParallel.h"
#include <omp.h>

////////////////////////////////////////////////////////////////////////////////
// Macros:
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Types:
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Prototypes:
////////////////////////////////////////////////////////////////////////////////

double runParallelMonteCarloPICalculation(int n);

////////////////////////////////////////////////////////////////////////////////
// Globals:
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Procedures:
////////////////////////////////////////////////////////////////////////////////

double runParallelMonteCarloPICalculation(int n) {
    int count = 0;
    std::default_random_engine generator;
    std::uniform_real_distribution<double> distribution(0.0, 1.0);

    #pragma omp parallel
    {
        int localCount = 0;
        unsigned seed = generator() + omp_get_thread_num();
        for (int i = 0; i < n / omp_get_num_threads(); ++i) {
            double x = distribution(generator);
            double y = distribution(generator);
        if (x * x + y * y <= 1.0) {
            localCount++;
        }
    }

    #pragma omp atomic
        count += localCount;
    }
  return 4.0 * count / n;
}
